<!DOCTYPE html>
<html>

<!-- Mirrored from developer.alexanderklimov.ru/android/theory/broadcast.php by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Jul 2014 14:51:53 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
<meta charset=utf-8>
<title>Android: Broadcast (Широковещательные сообщения)</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Le styles -->
<link href="../../assets/css/bootstrap.css" rel="stylesheet">
<style type="text/css">
  body {
    padding-top: 60px;
    padding-bottom: 10px;
  }
  .sidebar-nav {
    padding: 9px 0;
  }
</style>
	
<link href="../../assets/css/bootstrap-responsive.css" rel="stylesheet">
	
   <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    
<link rel="icon" href="../../favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />   
</head>

<body>

<div class="navbar navbar-inverse navbar-fixed-top">
    <div class="navbar-inner">
        <div class="container-fluid">
        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
        
        <div class="nav-collapse collapse">
          <p class="navbar-text pull-right">
			<a data-toggle="modal" href="#myModal" class="navbar-link">Гость</a>
          </p>
          <ul class="nav">
            
          </ul>
        </div><!--/.nav-collapse -->
        </div>
    </div>
</div>

<div class="row-fluid">
    <div class="span5">
        <p>
		<a href="http://developer.alexanderklimov.ru/"><img src="../../images/header.png" alt="Сайт разработчика Александр Климова" border="0"/></a>
		</p>
    
    </div><!--/span-->
    
	<div class="span5">
        <p style="color:green; font-style: italic; font-size: small;">
		/* Моя кошка замечательно разбирается в программировании. Стоит мне объяснить проблему ей - и все становится ясно. */<br>John Robbins, Debugging Applications, Microsoft Press, 2000
		</p>
    </div><!--/span-->
    
	<div class="span2">
        <p>
		<a href="http://feeds.feedburner.com/alexanderklimov/VJcl"><img src="../../kot-2-rss-100.png" border="0"></a>
		</p>
    </div><!--/span-->
</div><!--/row-->    
<div class="clearfix"></div>
    
<noindex><!--Rating@Mail.ru COUNTER--><script language="JavaScript" type="text/javascript"><!--
d=document;var a='';a+=';r='+escape(d.referrer)
js=10//--></script><script language="JavaScript1.1" type="text/javascript"><!--
a+=';j='+navigator.javaEnabled()
js=11//--></script><script language="JavaScript1.2" type="text/javascript"><!--
s=screen;a+=';s='+s.width+'*'+s.height
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth)
js=12//--></script><script language="JavaScript1.3" type="text/javascript"><!--
js=13//--></script><script language="JavaScript" type="text/javascript"><!--
d.write('<IMG src="http://db.c7.b3.a0.top.mail.ru/counter'+
'?id=228158;js='+js+a+';rand='+Math.random()+
'" height="1" width="1" alt="top.mail.ru" border="0" />')
if(11<js)d.write('<'+'!-- ')//--></script><noscript><img
src="http://top-fwz1.mail.ru/counter?js=na;id=228158"
height="1" width="1" alt="top.mail.ru" border="0" /></noscript><script language="JavaScript" type="text/javascript"><!--
if(11<js)d.write('--'+'>')//--></script><!--/COUNTER--></noindex><ul class="nav nav-pills">
<li class=""><a href="http://rusnetframework.blogspot.com/">Блог</a></li>
<li class=""><a href="http://developer.alexanderklimov.ru/index.php">C#/Visual Basic</a></li>
<li class=""><a href="http://developer.alexanderklimov.ru/windowsphone/wp.php">Windows Phone</a></li>
<li class=""><a href="http://developer.alexanderklimov.ru/wpf/wpf.php">WPF</a></li>
<li class=""><a href="http://developer.alexanderklimov.ru/php">PHP</a></li>
<li class=""><a href="http://developer.alexanderklimov.ru/silverlight/silverlight.php">Silverlight</a></li>
<li class="active"><a href="http://developer.alexanderklimov.ru/android">Android</a></li>
<li class=""><a href="http://developer.alexanderklimov.ru/arduino">Arduino</a></li>
</ul>
<div class="container-fluid">
    
    <div class="row-fluid">
        <!--левое меню -->
        <div class="span2">
            <div class="well sidebar-nav">
            <ul class="nav nav-list">
<li class=""><a href="../index-2.html">Главная</a></li>
<li class="active"><a href="index.html">Теория</a></li>
<li class=""><a href="../views.html">Palette</a></li>
<li class=""><a href="../listview/index.html">ListView</a></li>
<li class=""><a href="../catshop/catshop.html">Котошоп</a></li>
<li class=""><a href="../animation.html">Анимация</a></li>
<li class=""><a href="../sqlite/index.html">SQLite</a></li>
<li class=""><a href="../opengles/index.html">OpenGL ES</a></li>
<li class=""><a href="../library/index.html">Библиотеки</a></li>
<li class=""><a href="../games/index.html">Игры</a></li>
<li class=""><a href="../emulator.html">Эмулятор</a></li>
<li class=""><a href="../tips-android.html">Советы</a></li>
<li class=""><a href="../articles-android.html">Статьи</a></li>
<li class=""><a href="../books.html">Книги</a></li>
<li class=""><a href="../java/java.html">Java. Экспресс-курс</a></li>
<li class=""><a href="../design/index.html">Дизайн</a></li>
<li class=""><a href="../opensource.html">Open Source</a></li>
<li class=""><a href="../links.html">Полезные ресурсы</a></li>
</ul>            </div><!--/.well -->
        </div><!--/span-->


        <div class="span8">

        <div class="row-fluid">
            <div class="span12">
                
                        <div id="myModal" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
            <div class="modal-header">
              <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
              <h3 id="myModalLabel">Читайте на здоровье!</h3>
            </div>
            <div class="modal-body">
            
              <p>Статья проплачена кошками - всемирно известными производителями котят.</p>

            <p>Если статья вам понравилась, то можете <a href="http://developer.alexanderklimov.ru/donate.php">поддержать проект</a>.</p>
			
			            
            </div>
            <div class="modal-footer">
              <button class="btn" data-dismiss="modal">Закрыть</button>
              
            </div>
          </div>      
<h1 class="text-warning">Broadcast (Приёмник широковещательных сообщений)</h1>

<p>
<a href="#time_pick">Периодическое срабатывание каждую минуту</a><br>
<a href="#boot">Автостарт Activity или Service при загрузке (перезагрузке) девайса</a><br>
</p>

<p>В некоторых случаях система начинает рассылать специальные сообщения, предназначенные не кому-то отдельному приложению, объекту или компоненту, а всем. И любая программа, оборудованная специальным приёмником, может поймать это сообщение и предпринять свои шаги на основе полученной информации. Примерами таких сообщений могут быть:</p>

<ul>
<li>Низкий заряд батареи</li>
<li>Нажатие на кнопку камеры</li>
<li>Установка нового приложения</li>
</ul>

<p>Кроме системных сообщений, можно создавать свои собственные сообщения.</p>

<p>Есть два основных класса сообщений, которые могут быть получены специальным приемником широковещательных сообщений:</p>
<ul>
<li>нормальные сообщения о намерениях (Normal broadcasts) — посылаемые вызовом метода <b>context.sendBroadcast()</b> и являющиеся полностью асинхронными. Все получатели сообщения выполняются в неопределённом порядке, часто в одно и то же время. Это более эффективно, но означает, что получатели не могут использовать результат или прервать сообщение;</li>
<li>порядковые сообщения о намерениях (Ordered broadcasts), которые посылаются методом <b>Context.sendOrderedBroadcast()</b>. Эти сообщения посылаются одному получателю за один раз. Поскольку каждое полученное сообщение выполняется по очереди, он может в случае необходимости полностью прервать сообщение, чтобы его не успели передать другим приёмникам. Приёмниками сообщений можно управлять с помощью атрибута <b>android:priority</b> фильтра сообщений; приёмники сообщений, имеющие одинаковый приоритет, будут выполнены в произвольном порядке.</li>
</ul>

<h2 class="text-warning">Приёмники широковещательных сообщений</h2>

<p>Приёмник широковещательных сообщений — это компонент для получения внешних событий и реакции на них. Инициализировать передачи могут другие приложения или службы. Класс <b>BroadcastReceiver</b> является базовым для класса, в котором должны происходить получение и обработка сообщений, посылаемых клиентским 
приложением с помощью вызова метода <b>sendBroadcast()</b>. Вы можете или динамически зарегистрировать экземпляр класса BroadcastReceiver с помощью метода <b>Context.registerReceiver()</b>, или статически создать его в элементе &lt;receiver&gt; в файле манифеста приложения.</p>

<p>Хотя класс <b>Intent</b> используется для посылки и получения этих широковещательных сообщений, сам механизм широковещательных сообщений полностью отделен от намерений, используемых, например, чтобы запустить активность методом <b>Context.startActivity()</b>.</p>

<p>Для объекта <b>BroadcastReceiver</b> нет никаких возможностей видеть или фиксировать намерения, используемые в методе <b>startActivity()</b>. Аналогично, когда вы передали намерение для запуска активности через объект <b>BroadcastReceiver</b>, вы не сможете найти или запустить требуемую  активность. Эти две операции семантически полностью различаются: запуск активности через намерение является приоритетной операцией для системы, изменяющей содержимое экрана устройства, с которым в настоящее время взаимодействует пользователь. Передача широковещательных сообщений для системы является фоновой работой, о которой обычно не знает пользователь и которая, соответственно, имеет более низкий приоритет.</p>

<h3 class="text-warning">Жизненный цикл приемников широковещательных сообщений</h3>

<p>Приемник широковещательных сообщений имеет единственный метод обратного вызова:</p>
<pre> 
void onReceive(Context curContext, Intent broadcastMsg) 
</pre>

<p>Когда широковещательное сообщение прибывает для получателя сообщения, Android вызывает его методом <b>onReceive()</b> и передаёт в него объект <b>Intent</b>, содержащий сообщение. Приёмник широковещательных сообщений является активным только во время выполнения этого метода. Процесс, который в настоящее время выполняет <b>BroadcastReceiver</b>, т. е. выполняющийся в настоящее время код в методе обратного вызова <b>onReceive()</b>, как полагает система, является приоритетным процессом и будет сохранен, кроме случаев критического недостатка памяти в системе.</p>

<p>Когда программа возвращается из метода <b>onReceive()</b>, приёмник становится неактивным и система полагает, что работа объекта <b>BroadcastReceiver</b> закончена. Процесс с активным широковещательным получателем защищен от уничтожения системой. Однако процесс, содержащий неактивные компоненты, может быть уничтожен системой в любое время, когда память, которую он потребляет, будет необходима другим процессам.</p>

<p>Это представляет проблему, когда ответ на широковещательное сообщение занимает длительное время. Если метод <b>onReceive()</b> порождает отдельный поток, а затем возвращает управление, то полный процесс, включая и порожденный поток, система Android считает неактивным (если другие компоненты приложения не активны в процессе), и считает этот процесс кандидатом на уничтожение.</p>

<p>В частности, вы не можете отобразить диалог или осуществить связывание со службой внутри экземпляра <b>BroadcastReceiver</b>. Для первого случая необходимо вместо этого использовать методы класса <b>NotificationManager</b>. Во втором случае можно использовать вызов метода <b>Context.startService()</b>, чтобы послать команду для запуска службы.</p>

<p>Решение этой проблемы возможно, если запустить в методе <b>onReceive()</b> отдельную службу вместе с <b>BroadcastReceiver</b> и позволить службе выполнять задание, чтобы сохранить содержание процесса активным в течение всего времени вашей операции.</p>

<h2 class="text-warning">Приёмники системных событий</h2>

<p>Android использует широковещательные сообщения для системных событий, таких как уровень зарядки батареи, сетевые подключения, входящие звонки, изменения часового пояса, состояние подключения данных, входящие сообщения SMS или обращения по телефону. Вы можете использовать эти сообщения, чтобы добавлять к вашим собственным проектам новые функциональные возможности, основанные на системных событиях.</p>

<p>Следующий список показывает некоторые из встроенных действий, представленных как константы в классе <b>Intent</b>, которые используются для того, чтобы проследить изменения состояния устройства:</p>

<ul>
<li>ACTION_BOOT_COMPLETED — передается один раз, когда устройство завершило свою загрузку. Требует разрешения RECEIVE_BOOT_COMPLETED;</li>
<li>ACTION_CAMERA_BUTTON — передается при нажатии пользователем клавиши <b>Camera</b>;</li>
<li>ACTION_DATE_CHANGED И ACTION_TIME_CHANGED - запускаются при изменении даты или времени на устройстве вручную пользователем;</li>
<li>ACTION_SCREEN_OFF и ACTiON_SCREEN_ON — передаются, когда экран выключается или включается;</li>
<li>ACTION_TIMEZONE_CHANGED — передается при изменении текущего часового пояса</li>
</ul> 

<h2 class="text-warning">Использование широковещательных сообщений</h2>

<p>Можно реализовать приемники широковещательных сообщений, чтобы прослушивать сообщения, посылаемые другими компонентами, и отвечать на эти широковещательные сообщения в рамках собственного приложения.</p>

<p>Широковещательные сообщения также используются для уведомления слушателей системных или прикладных событий. Широковещательные  сообщения делают приложение более открытым; передавая события, использующие сообщения, вы открываете компоненты своего приложения для сторонних приложений, и сторонние разработчики реагируют на события без необходимости изменять ваше оригинальное приложение. В своем приложении вы можете прослушивать широковещательные сообщения других приложений, заменить или улучшить функциональность собственного (или стороннего) приложения или реагировать на системные изменения и события приложений.</p>

<h3 class="text-warning">Передача событий</h3>

<p>Передача сообщений весьма проста в реализации. В вашем приложении необходимо создать сообщение, которое вы хотите передать, и использовать вызов метода <b>sendBroadcast()</b>, чтобы послать это сообщение. Установите поля <b>action</b>, <b>data</b> и <b>category</b> (действие, данные и категорию) вашего сообщения и путь, который позволяет приемникам широковещательных сообщений точно определять "своё" сообщение. В этом сообщении строка действия используется, чтобы идентифицировать передаваемое действие, таким образом, это должна быть уникальная строка-идентификатор действия по правилам именования пакетов Java. Например, для сообщения для взаимодействия с медиаплеером можем объявить идентификатор:</p>

<pre> 
private static String ACTION = "ru.alexanderklimov.media.PLAYER"; 
</pre>

<p>Другой пример для обнаружения кота в большом здании:</p>

<pre>
public static final String NEW_CAT_DETECTED = "ru.alexanderklimov.action.NEW_CAT";
</pre>

<p>В коде, посылающем широковещательные сообщения с использованием идентификатора действия <b>ACTION</b> и с включением дополнительной информации, необходимо создать объект <b>Intent</b>, загрузить в него нужную информацию и вызвать метод <b>sendBroadcast()</b>, передав ему в качестве параметра созданный объект <b>Intent</b>.</p>

<p>Дополнительные данные можно использовать в <b>extras</b> как необязательные параметры.</p>

<pre><code class="java">
private static final String TYPE = "type"; 
private static final int ID_ACTION_PLAY = 0; 
Intent intent = new Intent(ACTION); 
intent.putExtra(TYPE, ID_ACTION_PLAY); 
sendBroadcast(intent); 
</code></pre>

<p>Или для обнаружения кота:</p>

<pre><code class="java">
Intent intent = new Intent(NEW_CAT_DETECTED);
intent.putExtra("catname", CatName);
intent.putExtra("longitude", currentLongitude);
intent.putExtra("latitude", currentLatitude);
sendBroadcast(intent);
</code></pre>

<h3 class="text-warning">Прослушивание событий приёмниками широковещательных сообщений</h3>

<p>Чтобы создать приёмник широковещательных сообщений, его необходимо зарегистрировать либо в коде, либо в манифесте приложения при помощи фильтра намерений, чтобы определить, какие сообщения приёмник должен прослушивать. Для этого надо в элементе &lt;appiication&gt; добавить элемент &lt;receiver&gt;, определяющий имя класса приёмника широковещательных сообщений для его регистрации.  Элемент &lt;receiver&gt; должен также включать фильтр намерений &lt;intent-filter&gt;, в котором нужно указать действие в виде строки. Например, для регистрации широковещательного приёмника для взаимодействия с медиаплеером файл манифеста будет иметь следующий вид:</p>

<pre><code class="xml">
&lt;application 
    &lt;receiver android:name=&quot;.PlayerReceiver&quot;&gt; 
        &lt;intent-fiiter&gt; 
            &lt;action android:name=&quot;ru.alexanderklimov.media.PLAYER&quot; /&gt; 
        &lt;/intent-filter&gt; 
    &lt;/receiver&gt; 
&lt;/application&gt; 
</code></pre>

<p>Если регистрация была сделана через манифест, приложение не обязано работать, чтобы ваш приёмник среагировал на трансляцию намерения. Приложение запустится автоматически, когда подходящие намерение будет транслировано. Т.е. система сама сканирует содержимое манифеста всех приложений и делает за нас всю работу. Это хорошее решение, позволяющее экономить ресурсы. Такой подход позволяет создавать приложения, способные реагировать на события даже после завершения или принудительного завершения.</p>

<p>Чтобы создать новый приёмник широковещательных сообщений, необходимо создать класс, расширяющий базовый класс <b>BroadcastReceiver</b> и реализовать метод обратного вызова <b>onReceive()</b> обработчика событий, как показано в примере:</p>

<pre><code class="java">
public class PlayerReceiver extends BroadcastReceiver
{ 
    private static final String TYPE = "type"; 
    private static final int ID_ACTION_PLAY = 0; 
    private static final int ID_ACTION_STOP = 1; 
    
    @Override 
    public void onReceive(Context context, Intent intent) 
    { 
        int type intent.getIntExtra(TYPE, ID_ACTION_STOP); 
        switch (type) 
        {
            case ID_ACTION_PLAY: 
            // выполнение полученного намерения 
            context.startService(new Intent(context, PlayService.class)); 
            break;
        } 
    }
}
</code></pre>

<p>Метод <b>onReceive()</b> будет выполнен при получении широковещательного намерения, если полученное намерение соответствует фильтру. Приложения с зарегистрированными приёмниками широковещательных намерений будут запущены автоматически при получении соответствующего намерения. Метод должен быть завершён в течение пяти секунд, иначе появится диалоговое окно о принудительном закрытии.</p>

<p>Также можно зарегистрировать широковещательный приёмник не через манифест, а программно. Приёмник, зарегистрированный таким способом, будет отвечать на поступающие намерения только в том случае, если компонент приложения, которому он принадлежит, выполняется в этот момент.</p>

<p>Это может быть полезным, когда приёмник используется для обновления элементов пользовательского интерфейса внутри активности, запуска сервисов или уведомления через <b>NotificationManager</b>. В таких случаях вы можете отменять регистрацию широковещательного приёмника, если активность не отображается на экране или находится в неактивном состоянии.</p>

<p>В коде программы можете написать приблизительно такой код (обычно используют метод <b>onResume()</b>):</p>

<pre><code class="java">
// Создаём и регистрируем широковещательный приёмник
IntentFilter filter = new IntentFilter(NEW_CAT_DETECTED);
CatDetectedBroadcastReceiver receiver = new CatDetectedBroadcastReceiver(receiver, filter);
</code></pre>

<p>Для отмены регистрации используется метод <b>unregisterReceiver()</b> в контексте приложения, передавая ему в качестве параметра экземпляр широковещательного приёмника (обычно в методе <b>onPause()</b>):</p>

<pre><code class="java">
unregisterReceiver(receiver);
</code></pre>

<h3 class="text-warning">Трансляция упорядоченных намерений</h3>

<p>Если важно, чтобы приёмники получали намерения в определённом порядке или могли влиять на транслируемое намерение, можно использовать метод <b>sendOrderedBroadcast()</b>:</p>

<pre><code class="java">
String requiredPermission = "ru.alexanderklimov.MY_BROADCAST_PERMISSION";
sendOrderedBroadcast(intent, requiredPermission);
</code></pre>

<p>С помощью этого метода ваше намерение дойдёт до всех зарегистрированных приёмников, обладающих необходимым доступом (если он был указан), в порядке их приоритета. Приоритет задаётся с помощью атрибута <b>android:priority</b> внутри узла фильтра намерений в манифесте. Чем больше значение, тем выше приоритет.</p>

<p>Производить упорядоченные трансляции с использованием приоритетов рекомендуется только для тех приёмников, которым необходим конкретный порядок приёма сообщений.</p>


<h2 class="text-warning" id="time_pick">Периодическое срабатывание каждую минуту</h2>

<p>Рассмотрим на примере периодического срабатывания каждую минуту по шагам. Создадим новый проект. Добавим на экран активности две кнопки для регистрации и отмены регистрации широковещательного сообщения.</p>

<pre><code class="xml">
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;
    tools:context=&quot;.MainActivity&quot; &gt;

    &lt;Button
        android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:onClick=&quot;registerBroadcastReceiver&quot;
        android:text=&quot;Регистрация&quot;
        tools:context=&quot;.MainActivity&quot; /&gt;

    &lt;Button
        android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:onClick=&quot;unregisterBroadcastReceiver&quot;
        android:text=&quot;Отмена&quot;
        tools:context=&quot;.MainActivity&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre>

<p>Создадим новый класс <b>TimeBroadcastReceiver</b>, наследующий от <b>BroadcastReceiver</b>:</p>

<pre><code class="java">
package ru.alexanderklimov.broadcastreceiver;

import java.text.Format;
import java.text.SimpleDateFormat;
import java.util.Date;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.widget.Toast;

public class TimeBroadcastReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(Context context, Intent intent) {
        // TODO Auto-generated method stub
        StringBuilder msgStr = new StringBuilder("Текущее время: ");
        Format formatter = new SimpleDateFormat("hh:mm:ss a");
        msgStr.append(formatter.format(new Date()));
        Toast.makeText(context, msgStr, Toast.LENGTH_SHORT).show();
    }
}
</code></pre>

<p>Откроем код главной активности:</p>

<pre><code class="java">
package ru.alexanderklimov.broadcastreceiver;

import android.os.Bundle;
import android.app.Activity;
import android.content.IntentFilter;
import android.view.Menu;
import android.view.View;
import android.widget.Toast;

public class MainActivity extends Activity {

    TimeBroadcastReceiver timeBroadCastReceiver = new TimeBroadcastReceiver();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.main, menu);
        return true;
    }

    // регистрируем широковещательное сообщениеThis method enables the Broadcast
    // receiver for
    // для намерения "android.intent.action.TIME_TICK". This intent get
    // Данное намерение срабатывает каждую минуту
    public void registerBroadcastReceiver(View view) {
        this.registerReceiver(timeBroadCastReceiver, new IntentFilter(
                "android.intent.action.TIME_TICK"));
        Toast.makeText(this, "Широковещательное сообщение включено",
                Toast.LENGTH_SHORT).show();
    }

    // Отменяем регистрацию
    public void unregisterBroadcastReceiver(View view) {
        this.unregisterReceiver(timeBroadCastReceiver);

        Toast.makeText(this, "Широковещательное сообщение выключено", Toast.LENGTH_SHORT)
                .show();
    }
}
</code></pre>

<p>Запускаем проект и нажимаем на первую кнопку, чтобы включить рассылку широковещательного сообщения. Теперь каждую минуту будет срабатывать запуск всплывающего сообщения с текущим временем. Даже если вы переключитесь на другое приложение, то всё равно будете видеть сообщения.</p>

<h2 class="text-warning" id="boot">Автостарт Activity или Service при загрузке (перезагрузке) девайса</h2>

<p>Если ваше приложение (сервис) должно запускаться сразу после перезагрузки устройства, то используйте <b>BroadcastReceiver</b>:</p>

<pre><code class="java">
public class BootReceiver extends BroadcastReceiver {
    Context mContext;
    private final String BOOT_ACTION = "android.intent.action.BOOT_COMPLETED";

    @Override
    public void onReceive(Context context, Intent intent) {
        mContext = context;
        String action = intent.getAction();
        if (action.equalsIgnoreCase(BOOT_ACTION)) {
            // здесь ваш код
            // например, запускаем уведомление
            Intent intent = new Intent(context, ru.alexanderklimov.NotifyService.NotifyService.class);
            context.startService(intent);
            // в общем виде
            //для Activity 
            Intent activivtyIntent = new Intent(context, MyActivity.class);  
            ativivtyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            context.startActivity(activivtyIntent);  
              
            //для Service
            Intent serviceIntent = new Intent(context, MyService.class);
            context.startService(serviceIntent);
        }
    }
}
</code></pre>

<p>Мы создали отдельный класс для широковещательного сообщения. Также нужно создать разрешение в манифесте.</p>

<pre><code class="xml">
&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;

&lt;receiver android:enabled=&quot;true&quot; android:name=&quot;.BootReceiver&quot;
        android:permission=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;&gt;

        &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;
                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
        &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre>

<p>Необходимо помнить, что программная регистрация широковещательного сообщения создаётся в основном потоке приложения и это может послужить источником ошибок, если операции в <b>BroadcastReceiver</b> занимают длительное время. Как вариант, используйте сервисы. Почитайте на эту тему <a href="http://gmariotti.blogspot.ru/2013/02/antipattern-freezing-ui-with-broadcast.html">статью (en)</a>.</p>

<h2 class="text-warning">Другие примеры</h2>

<p><a href="../battery.html#getlevel">Получаем показания батареи в реальном времени</a></p>
<p><a href="../wifi.html#statechange">Отслеживание состояния соединения Wi-Fi</a></p>
<p><a href="../downloadmanager.html" >DownloadManager</a></p>
<p><a href="../secretcode.html" >Секретный код</a></p>

<h5 class="text-error">Реклама</h5>

<script type="text/javascript"><!--
google_ad_client = "ca-pub-4224968932772057";
/* Полноразмерный баннер 728х90 */
google_ad_slot = "4077523505";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="../../../pagead2.googlesyndication.com/pagead/f.txt">
</script>


</div><!--/span-->
        </div><!--/row-->    
          
        </div><!--/span-->
        
        <div class="span2">
            <div class="well sidebar-nav">
    <h4><span class="label label-info">Реклама</span></h4>
    <script type="text/javascript"><!--
    google_ad_client = "pub-4224968932772057";
    /* 120x600AlexKlimov */
    google_ad_slot = "0305552138";
    google_ad_width = 120;
    google_ad_height = 600;
    //-->
    </script>
    <script type="text/javascript"
    src="../../../pagead2.googlesyndication.com/pagead/f.txt">
    </script>
</div><!--/.well -->        </div><!--/span-->
        
      </div><!--/row-->
      
    
      <hr>
      
	  	  <div class="row-fluid">
	  <div class="span12">
	  <img src="../../images/cat_bottom.png" align="right" />
</div><!--/span-->
        </div><!--/row-->

<footer>
    <noindex>
    <span style="float:left; margin:3px 1px 1px 2px;">
	    © 2014 <a href="mailto:rusproject@mail.ru">А.Климов</a>
		
		<!-- Place this code where you want the badge to render. -->
<a href="http://plus.google.com/109061106977829925124?prsrc=3" rel="publisher" style="text-decoration:none;">
<img src="../../../ssl.gstatic.com/images/icons/gplus-16.png" alt="Google+" style="border:0;width:16px;height:16px;"/></a>

    </span>
	
		<span style="float: right; margin:3px 5px 1px 1px; font-size:22px;">
        <!--Rating@Mail.ru LOGO--><a target=_top
        href="http://top.mail.ru/jump?from=228158"><img
        SRC="http://top-fwz1.mail.ru/counter?id=228158;t=223;l=1"
        border=0 height=31 width=88
        alt="Рейтинг@Mail.ru"/></a><!--/LOGO-->
	</span>
    
    <span style="float: right; margin:2px 70px 1px 1px; font-size:22px;">
        <a href="http://feeds.feedburner.com/alexanderklimov/VJcl"><img src="../../../feeds.feedburner.com/_fc/alexanderklimov/VJcle080.gif?bg=0099CC&amp;fg=444444&amp;anim=0" height="26" width="88" style="border:0" alt="" /></a>
	</span>
	
<div style="float: right; margin:2px 70px 1px 1px;">
<!-- Place this tag where you want the +1 button to render. -->
<div class="g-plusone" data-size="small" data-annotation="inline" data-width="300" data-align="right" ></div>

</div>

<!-- Place this tag after the last +1 button tag. -->
<script type="text/javascript">
  window.___gcfg = {lang: 'ru'};

  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '../../../apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
	

    </noindex>
</footer>

</div><!--/.fluid-container-->
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../../assets/js/jquery.js"></script>
    <script src="../../assets/js/bootstrap-transition.js"></script>
    <script src="../../assets/js/bootstrap-alert.js"></script>
    <script src="../../assets/js/bootstrap-modal.js"></script>
    <script src="../../assets/js/bootstrap-dropdown.js"></script>
    <script src="../../assets/js/bootstrap-scrollspy.js"></script>
    <script src="../../assets/js/bootstrap-tab.js"></script>
    <script src="../../assets/js/bootstrap-tooltip.js"></script>
    <script src="../../assets/js/bootstrap-popover.js"></script>
    <script src="../../assets/js/bootstrap-button.js"></script>
    <script src="../../assets/js/bootstrap-collapse.js"></script>
    <script src="../../assets/js/bootstrap-carousel.js"></script>
    <script src="../../assets/js/bootstrap-typeahead.js"></script>
    <script src="../../../code.jquery.com/jquery-1.7.min.js"></script>
</body>

<!-- Mirrored from developer.alexanderklimov.ru/android/theory/broadcast.php by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Jul 2014 14:51:53 GMT -->
</html>