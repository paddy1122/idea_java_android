<!DOCTYPE html>
<html>

<!-- Mirrored from developer.alexanderklimov.ru/android/theory/asynctask.php by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Jul 2014 14:51:50 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
<meta charset=utf-8>
<title>Android: AsyncTask</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Le styles -->
<link href="../../assets/css/bootstrap.css" rel="stylesheet">
<style type="text/css">
  body {
    padding-top: 60px;
    padding-bottom: 10px;
  }
  .sidebar-nav {
    padding: 9px 0;
  }
</style>
	
<link href="../../assets/css/bootstrap-responsive.css" rel="stylesheet">
	
   <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    
<link rel="icon" href="../../favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />
</head>

<body>

<div class="navbar navbar-inverse navbar-fixed-top">
    <div class="navbar-inner">
        <div class="container-fluid">
        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
        
        <div class="nav-collapse collapse">
          <p class="navbar-text pull-right">
			<a data-toggle="modal" href="#myModal" class="navbar-link">Гость</a>
          </p>
          <ul class="nav">
            
          </ul>
        </div><!--/.nav-collapse -->
        </div>
    </div>
</div>

<div class="row-fluid">
    <div class="span5">
        <p>
		<a href="http://developer.alexanderklimov.ru/"><img src="../../images/header.png" alt="Сайт разработчика Александр Климова" border="0"/></a>
		</p>
    
    </div><!--/span-->
    
	<div class="span5">
        <p style="color:green; font-style: italic; font-size: small;">
		/* Моя кошка замечательно разбирается в программировании. Стоит мне объяснить проблему ей - и все становится ясно. */<br>John Robbins, Debugging Applications, Microsoft Press, 2000
		</p>
    </div><!--/span-->
    
	<div class="span2">
        <p>
		<a href="http://feeds.feedburner.com/alexanderklimov/VJcl"><img src="../../kot-2-rss-100.png" border="0"></a>
		</p>
    </div><!--/span-->
</div><!--/row--><noindex><!--Rating@Mail.ru COUNTER--><script language="JavaScript" type="text/javascript"><!--
d=document;var a='';a+=';r='+escape(d.referrer)
js=10//--></script><script language="JavaScript1.1" type="text/javascript"><!--
a+=';j='+navigator.javaEnabled()
js=11//--></script><script language="JavaScript1.2" type="text/javascript"><!--
s=screen;a+=';s='+s.width+'*'+s.height
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth)
js=12//--></script><script language="JavaScript1.3" type="text/javascript"><!--
js=13//--></script><script language="JavaScript" type="text/javascript"><!--
d.write('<IMG src="http://db.c7.b3.a0.top.mail.ru/counter'+
'?id=228158;js='+js+a+';rand='+Math.random()+
'" height="1" width="1" alt="top.mail.ru" border="0" />')
if(11<js)d.write('<'+'!-- ')//--></script><noscript><img
src="http://top-fwz1.mail.ru/counter?js=na;id=228158"
height="1" width="1" alt="top.mail.ru" border="0" /></noscript><script language="JavaScript" type="text/javascript"><!--
if(11<js)d.write('--'+'>')//--></script><!--/COUNTER--></noindex><ul class="nav nav-pills">
<li class=""><a href="http://rusnetframework.blogspot.com/">Блог</a></li>
<li class=""><a href="http://developer.alexanderklimov.ru/index.php">C#/Visual Basic</a></li>
<li class=""><a href="http://developer.alexanderklimov.ru/windowsphone/wp.php">Windows Phone</a></li>
<li class=""><a href="http://developer.alexanderklimov.ru/wpf/wpf.php">WPF</a></li>
<li class=""><a href="http://developer.alexanderklimov.ru/php">PHP</a></li>
<li class=""><a href="http://developer.alexanderklimov.ru/silverlight/silverlight.php">Silverlight</a></li>
<li class="active"><a href="http://developer.alexanderklimov.ru/android">Android</a></li>
<li class=""><a href="http://developer.alexanderklimov.ru/arduino">Arduino</a></li>
</ul>
<div class="container-fluid">
    
	<div class="row-fluid">
        <!--левое меню -->
		<div class="span2">
            <div class="well sidebar-nav">
            <ul class="nav nav-list">
<li class=""><a href="../index-2.html">Главная</a></li>
<li class="active"><a href="index.html">Теория</a></li>
<li class=""><a href="../views.html">Palette</a></li>
<li class=""><a href="../listview/index.html">ListView</a></li>
<li class=""><a href="../catshop/catshop.html">Котошоп</a></li>
<li class=""><a href="../animation.html">Анимация</a></li>
<li class=""><a href="../sqlite/index.html">SQLite</a></li>
<li class=""><a href="../opengles/index.html">OpenGL ES</a></li>
<li class=""><a href="../library/index.html">Библиотеки</a></li>
<li class=""><a href="../games/index.html">Игры</a></li>
<li class=""><a href="../emulator.html">Эмулятор</a></li>
<li class=""><a href="../tips-android.html">Советы</a></li>
<li class=""><a href="../articles-android.html">Статьи</a></li>
<li class=""><a href="../books.html">Книги</a></li>
<li class=""><a href="../java/java.html">Java. Экспресс-курс</a></li>
<li class=""><a href="../design/index.html">Дизайн</a></li>
<li class=""><a href="../opensource.html">Open Source</a></li>
<li class=""><a href="../links.html">Полезные ресурсы</a></li>
</ul>            </div><!--/.well -->
        </div><!--/span-->


        <div class="span8">

		<div class="row-fluid">
            <div class="span12">
			
			            <div id="myModal" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
            <div class="modal-header">
              <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
              <h3 id="myModalLabel">Читайте на здоровье!</h3>
            </div>
            <div class="modal-body">
            
              <p>Статья проплачена кошками - всемирно известными производителями котят.</p>

            <p>Если статья вам понравилась, то можете <a href="http://developer.alexanderklimov.ru/donate.php">поддержать проект</a>.</p>
			
			            
            </div>
            <div class="modal-footer">
              <button class="btn" data-dismiss="modal">Закрыть</button>
              
            </div>
          </div>
<h1 class="text-warning">Класс AsyncTask</h1>

<p>
<a href="#newtask">Создание новой асинхронной задачи</a><br>
<a href="#simple">Простой пример для знакомства. Кот полез на крышу</a><br>
<a href="#parameters">Использование параметров</a><br>
<a href="#second">Используем второй параметр - промежуточные данные</a><br>
<a href="#first">Используем первый параметр - входящие данные</a><br>
<a href="#third">Используем третий параметр - возвращаемые данные</a><br>
<a href="#getmethod">Метод get()</a><br>
<a href="#cancelmethod">Метод cancel() - отменяем задачу</a><br>
<a href="#asyncstatus">Текущее состояние задачи</a><br>
<a href="#rotatescreen">Поворот экрана</a><br>
</p>

<h2 class="text-warning" id="newtask">Создание новой асинхронной задачи</h2>

<p>Класс <b>AsyncTask</b> предлагает простой и удобный механизм для перемещения трудоёмких операций в фоновый поток. Благодаря ему вы получаете удобство синхронизации обработчиков событий с графическим потоком, что позволяет обновлять элементы пользовательского интерфейса для отчета о ходе выполнения задачи или для вывода результатов, когда задача завершена.</p>

<p>AsyncTask создает, синхронизирует потоки, а также управляет ими, что позволяет создавать асинхронные задачи, состоящие из операций, выполняющихся в фоновом режиме, и обновлять пользовательский интерфейс по их завершении.</p>

<p>Напрямую с классом <b>AsyncTask</b> нельзя, вам нужно наследоваться от него (extends). Ваша реализация должна предусматривать классы для объектов, которые будут переданы в качестве параметров методу execute(), для переменных, что станут использоваться для оповещения о ходе выполнения, а также для переменных, где будет храниться результат. Формат такой записи следующий:</p>

<pre><code class="java">
AsyncTask&lt;[Input Parameter Type], [Progress Report Type], [Result Type]&gt;
</code></pre>

<p>Если не нужно принимать параметры, обновлять информацию о ходе выполнения или выводить конечный результат, просто укажите тип <b>Void</b> во всех трёх случаях.</p>

<p> Каркас реализации AsyncTask, в котором используются строковой параметр и два целочисленных значения, нужных для оповещения о выполнении работы и о конечном результате:</p>

<pre><code class="java">
private class MyAsyncTask extends AsyncTask&lt;String, Integer, Integer&gt; {
    @Override
    protected void onProgressUpdate(Integer... progress) {
        // [... Обновите индикатор хода выполнения, уведомления или другой   
        // элемент пользовательского интерфейса ...]
    }
    
	@Override
    protected void onPostExecute(Integer... result) {
        // [... Сообщите о результате через обновление пользовательского 
        // интерфейса, диалоговое окно или уведомление ...]
    }
   
   @Override
    protected Integer doInBackground(String... parameter) {
        int myProgress = 0;
        // [... Выполните задачу в фоновом режиме, обновите переменную myProgress...]
        publishProgress(myProgress);
        // [... Продолжение выполнения фоновой задачи ...]
        // Верните значение, ранее переданное в метод onPostExecute
        return result;
    }
}
</code></pre>

<p>У <b>AsyncTask</b> есть несколько основных методов, которые нужно освоить в первую очередь. Обязательным является метод <b>doInBackground()</b>, остальные опциональны, но используются часто.</p>

<ul>
<li><b>doInBackground()</b> – основной метод, который выполняется в новом потоке. <b class="text-error">Не имеет доступа к UI</b>. Именно в этом методе должен находиться код для тяжелых задач. Принимает набор параметров тех типов, которые определены в реализации вашего класса. Этот метод выполняется в фоновом потоке, поэтому в нем не должно быть никакого взаимодействия с элементами пользовательского интерфейса. Размещайте здесь трудоёмкий код, используя метод publishProgress(), который позволит обработчику onProgressUpdate() передавать изменения в пользовательский интерфейс. Когда фоновая задача завершена, данный метод возвращает конечный результат для обработчика onPostExecute(), который сообщит о нём в поток пользовательского интерфейса.</li>
<li><b>onPreExecute()</b> – выполняется перед doInBackground(). <b class="text-success">Имеет доступ к UI</b></li>
<li><b>onPostExecute()</b> – выполняется после doInBackground() (может не вызываться, если AsyncTask был отменен). <b class="text-success">Имеет доступ к UI</b>. Используйте его для обновления пользовательского интерфейса, как только ваша фоновая задача завершена. Данный обработчик при вызове синхронизируется с потоком GUI, поэтому внутри него вы можете безопасно изменять элементы пользовательского интерфейса.</li>
<li><b>onProgressUpdate</b>. <b class="text-success">Имеет доступ к UI</b>. Переопределите этот обработчик для публикации промежуточных обновлений в пользовательский интерфейс. При вызове он синхронизируется с потоком GUI, поэтому в нём вы можете безопасно изменять элементы пользовательского интерфейса.</li>
</ul>

<p>Вкратце о том, что значит имеет/не имеет доступ к UI. Все ваши кнопки, текстовые метки, ImageView (всё, что отображается на экране) являются часть пользовательского интерфейса - User Interface (UI). Ваша задача - не допустить, чтобы в методе <b>doInBackground()</b> было обращение к какому-нибудь элементу. Например, нельзя установить текст в TextView через метод <b>setText()</b> или поменять цвет шрифта в EditText. В примерах вы увидите, как нужно делать подобные вещи.</p>

<h2 class="text-warning" id="simple">Простой пример для знакомства. Кот полез на крышу</h2>

<p>Напишем простой пример с использованием названных методов. Предположим, мы хотим описать процесс восхождения котов на крышу. Всегда оставалось загадкой, как они умудряются залезать на крышу, но, очевидно, что это очень сложная работа, которую удобно использовать в отдельном потоке.</p>

<details>
    <summary>Подробности под <del>котом</del> катом</summary>
<p>
Наступил март. Две кошки полезли на крышу, котов снимать. Видят, возле трубы два кота - один сибирский, а другой простой, помойный. Та, что пошустрее, своей подруге:<br>
- Чур, мой сибирский.<br>
Второй ничего не оставалось делать, как идти с помойным. Договорились утром встретиться.<br>
Встречаются. Та, что пошустрее, спрашиваэт подругу:<br>
- Ну как?<br>
-Супер! Даром что помойный, драл меня всю ночь без остановки! А ты как?<br>
- А мне не повезло. Мой сибирский всю ночь водил меня по крышам и рассказывал как в Сибири яйца отморозил.
</p>
</details>
<br>
<p>Выведем на экран слово <b>Полез на крышу</b> в методе <b>onPreExecute()</b>, эмулируем тяжёлый код в методе <b>doInBackground()</b>, выведем на экран слово <b>Залез</b> в методе <b>onPostExecute()</b>.</p>

<p>Создадим новый проект и добавим на экран кнопку, индикатор прогресса и текстовую метку:</p>

<pre><code class="xml">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;fill_parent&quot;
    android:layout_height=&quot;fill_parent&quot;
    android:orientation=&quot;vertical&quot; &gt;

    &lt;Button
        android:id=&quot;@+id/buttonStart&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:onClick=&quot;onclick&quot;
        android:text=&quot;Поехали&quot; &gt;
    &lt;/Button&gt;

    &lt;ProgressBar
        android:id=&quot;@+id/progress&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot; &gt;
    &lt;/ProgressBar&gt;

    &lt;TextView
        android:id=&quot;@+id/tvInfo&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;&quot; &gt;
    &lt;/TextView&gt;

&lt;/LinearLayout&gt;
</code></pre>

<p>При щелчке на кнопке должна запуститься тяжёлая задача. Это может быть загрузка файла из сети, обработка большого изображения, сохранение больших данных в файл или в базу данных. В нашем случае - кот полез на крышу. В TextView будем выводить текущую информацию. Компонент ProgressBar будет показывать нам, что приложение не зависло во время выполнения задачи.</p>

<p>Сначала напишем код, а потом будет объяснение к нему.</p>

<pre><code class="java">
// Если этот код работает, его написал Александр Климов,
// а если нет, то не знаю, кто его писал.
package ru.alexanderklimov.asynctaskdemo;

import ...

public class MainActivity extends Activity {

	CatTask cattask;
	TextView tvInfo;

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);

		tvInfo = (TextView) findViewById(R.id.tvInfo);
	}

	public void onclick(View v) {
		cattask = new CatTask();
		cattask.execute();
	}

	class CatTask extends AsyncTask&lt;Void, Void, Void&gt; {

		@Override
		protected void onPreExecute() {
			super.onPreExecute();
			tvInfo.setText("Полез на крышу");
		}

		@Override
		protected Void doInBackground(Void... params) {
			try {
				TimeUnit.SECONDS.sleep(5);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			return null;
		}

		@Override
		protected void onPostExecute(Void result) {
			super.onPostExecute(result);
			tvInfo.setText("Залез");
		}
	}
}
</code></pre>

<p>Запустите проект и нажмите на кнопку. Сначала появится текст "Полез на крышу", который через 5 секунд сменится надписью "Залез". Индикаторе прогресса при этом будет постоянно крутиться.</p>

<p>У кота одна задача - залезть на крышу. Поэтому мы создали новую задачу <b>CatTask</b>, которая наследуется от AsyncTask. Для первого примера мы пока использовали <b>Void</b>, чтобы пока не связываться с параметрами.</p>

<p>В методе <b>onPreExecute()</b> мы устанавливаем начальный текст перед выполнением задачи.</p>

<p>В методе <b>doInBackground()</b> идёт имитация тяжёлой работы. Напоминаю, что здесь нельзя писать код, связанный с пользовательским интерфейсом. Ради интереса поместите в методе строчку:</p>

<pre><code class="java">
tvInfo.setText("Лезу на крышу. Чуть-чуть осталось");
</code></pre>

<p>В этом случае приложение запустится, но при выполнении задачи завершится с ошибкой. Оно вам надо?</p>

<p>В методе <b>onPostExecute()</b> мы выводим сообщение, которое появится после выполнения задачи.</p>

<p>Обратите внимание, что если мы нажмем на кнопку, пока работает AsyncTask, то создастся и запустится новая задача поверх старой. Получается, что две задачи будут одновременно работать с экраном активности. Нужно избегать подобных ситуаций. Позже я покажу, как это сделать.</p>

<p>На данный момент для избежания конфликтов можно скрыть кнопку в методе <b>onPreExecute()</b> и показать её снова в <b>onPostExecute()</b>:</p>

<pre><code class="java">
buttonStart.setVisibility(View.INVISIBLE); // прячем кнопку
buttonStart.setVisibility(View.VISIBLE);  // показываем кнопку
</code></pre>

<p>Сама задача CatTask (объект AsyncTask) создаётся в UI-потоке. Также в UI-потоке вызывается его метод <b>execute()</b></p>

<div class="alert">
Каждый экземпляр класса AsyncTask может быть запущен всего один раз. Попытка повторного вызова метода execute() приведет к выбросу исключения.
</div>

<p>Кстати, коты прислали фотографию, которая объясняет, зачем они лезут на крышу. Интересно, откуда они узнали про эту статью?</p>

<p><img src="roofcat.jpg" alt="Кот на крыше" width="400" height="287"></p>

<h2 class="text-warning" id="parameters">Использование параметров</h2>

<p>Для первого примера мы не использовали параметры. Наша задача была показать сообщения до и после выполнения задачи. Но часто нам необходимо знать промежуточные результаты выполняемой задачи. Например, мы хотим знать, что кот сейчас на втором этаже и ему осталось ещё двенадцать (бедный кот).</p>

<p>Когда мы создавали свой класс <b>CatTask</b>, то использовали угловые скобки, в которых необходимо указать три типа данных:</p>

<ol>
<li>Тип входных данных</li>
<li>Тип промежуточных данных, которые используются для вывода промежуточных результатов</li>
<li>Тип возвращаемых данных</li>
</ol>

<p>В первом примере мы указали &lt;Void, Void, Void&gt;. Эта запись означает, что мы не будем использовать параметры.</p>

<p>Во втором примере попробуем воспользоваться ими.</p>

<h3 class="text-warning" id="second">Используем второй параметр - промежуточные данные</h3>

<p>Начнём со второго параметра, который отвечает за промежуточные данные. Итак, нам нужно знать текущий этаж, на котором находится кот. Если дом 14-этажный, то у нас должны быть значения от 1 до 14 типа <i>Integer</i>:</p>

<pre><code class="java">
class CatTask extends AsyncTask&lt;Void, Integer, Void&gt;
</code></pre>

<p>Метод <b>onPreExecute()</b> оставляем без изменений, здесь мы просто выводим сообщение о начале штурма здания.</p>

<p>Переходим к методу <b>doInBackground()</b>. Мы пока не используем входящие данные, поэтому пока здесь используется <b>Void</b>. В самом методе создаётся цикл от 0 до 14 и при каждом проходе цикла увеличивается счётчик <i>counter</i> на единицу.</p>

<p>В методе <b>doInBackground()</b> вызываются два метода. Первый метод <b>getFloor()</b> - наш. Здесь мы реализуем свою логику тяжёлой работы. Воспринимайте его как эмуляцию загрузки файлов или другую сложную работу. В нашем случае при покорении очередного этажа кот должен пометить его, нацарапать на стене неприличное слово из трёх букв типа МЯУ или МУР. В вашем приложении возможно это будет код обработки большой картинки, скачанной по сети. Пока у нас здесь просто пауза на одну секунду.</p>

<p>Второй метод <b>publishProgress()</b> - системный метод. Когда мы в методе <b>doInBackground()</b> вызываем метод <b>publishProgress()</b> и передаём туда данные, то срабатывает метод <b>onProgressUpdate()</b>, который получает эти данные. Тип принимаемых данных равен второму типу из угловых скобок, у нас это Integer. Метод <b>onProgressUpdate()</b> используется для вывода промежуточных результатов и имеет доступ к UI. Таким образом, метод <b>publishProgress()</b> является своеобразным мостиком для передачи данных из <b>doInBackground()</b> в <b>onProgressUpdate()</b>. Мы передаём значение счётчика, которое выводится в текствой метке.</p>

<pre><code class="java">
@Override
protected void onProgressUpdate(Integer... values) {
	super.onProgressUpdate(values);
	tvInfo.setText("Этаж: " + values[0]);
}
</code></pre>

<p>При запуске проекта, вы увидите, как в текстовом поле будут меняться числа от 0 до 14.</p>

<p>Для наглядности можно добавить на экран горизонтальный ProgressBar, который будет показывать в удобном виде график прохождения этажей.</p>

<p><img src="asynctask1.png" alt="AsyncTask" width="240" height="400"></p>

<p>Полностью код будет следующим:</p>

<pre><code class="java">
// Если этот код работает, его написал Александр Климов,
// а если нет, то не знаю, кто его писал.
package ru.alexanderklimov.asynctaskdemo;

import ...

public class MainActivity extends Activity {

	CatTask cattask;
	TextView tvInfo;
	ProgressBar progress;
	Button buttonStart;
	ProgressBar horizontalprogress;

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);

		progress = (ProgressBar) findViewById(R.id.progress);
		tvInfo = (TextView) findViewById(R.id.tvInfo);
		buttonStart = (Button) findViewById(R.id.buttonStart);
		horizontalprogress = (ProgressBar) findViewById(R.id.progress2);

	}

	public void onclick(View v) {
		cattask = new CatTask();
		cattask.execute();
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		getMenuInflater().inflate(R.menu.activity_main, menu);
		return true;
	}

	class CatTask extends AsyncTask&lt;Void, Integer, Void&gt; {

		@Override
		protected void onPreExecute() {
			super.onPreExecute();
			tvInfo.setText("Полез на крышу");
			buttonStart.setVisibility(View.INVISIBLE);
		}

		@Override
		protected Void doInBackground(Void... params) {
			try {
				int counter = 0;

				for (int i = 0; i &lt; 14; i++) {
					getFloor(counter);
					publishProgress(++counter);
				}
				// разъединяемся
				TimeUnit.SECONDS.sleep(1);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			return null;
		}

		@Override
		protected void onProgressUpdate(Integer... values) {
			super.onProgressUpdate(values);
			tvInfo.setText("Этаж: " + values[0]);
			horizontalprogress.setProgress(values[0]);
		}

		@Override
		protected void onPostExecute(Void result) {
			super.onPostExecute(result);
			tvInfo.setText("Залез");
			buttonStart.setVisibility(View.VISIBLE);
			horizontalprogress.setProgress(0);
		}

		private void getFloor(int floor) throws InterruptedException {
			TimeUnit.SECONDS.sleep(1);
		}
	}
}
</code></pre>

<h3 class="text-warning" id="first">Используем первый параметр - входящие данные</h3>

<p>Теперь попробуем задействовать первый параметр, который отвечает за входящие данные. На практике это может быть список адресов, с которых надо загрузить картинки или что-то в этом роде.</p>

<p>Изменим объявление метода <b>doInBackground()</b>:</p>

<pre><code class="java">
protected Void doInBackground(String... urls)
</code></pre>

<p>Теперь у метода есть входные параметры типа <i>String</i>. Сразу поменяем первый параметр в классе CatTask:</p>

<pre><code class="java">
class CatTask extends AsyncTask&lt;String, Integer, Void&gt; {
}
</code></pre>

<p>Теперь нужно передать в метод <b>execute()</b> список адресов файлов для загрузки. Метод <b>doInBackground</b> принимает эти данные и в цикле по одному загружает эти файлы. Дальше без изменений. После прохождения каждого этажа (загрузки каждого файла) вызывается метод <b>publishProgress()</b>, в который передаются данные.</p>

<p>В обработчике кнопки вызовем метод <b>execute()</b>, которому передадим набор строк, так как мы указали этот тип в угловых скобках на первом месте.</p>

<pre><code class="java">
cattask.execute("cat1.jpg", "cat2.jgp", "cat3.jpg", "cat4.jpg");
</code></pre>

<p>Полностью код будет следующим:</p>

<details>
    <summary>Показать код (щелкните мышкой)</summary>
<pre><code class="java">
// Если этот код работает, его написал Александр Климов,
// а если нет, то не знаю, кто его писал.
package ru.alexanderklimov.asynctaskdemo;

import ...

public class MainActivity extends Activity {

	CatTask cattask;
	TextView tvInfo;
	ProgressBar progress;
	Button buttonStart;
	ProgressBar horizontalprogress;

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);

		progress = (ProgressBar) findViewById(R.id.progress);
		tvInfo = (TextView) findViewById(R.id.tvInfo);
		buttonStart = (Button) findViewById(R.id.buttonStart);
		horizontalprogress = (ProgressBar) findViewById(R.id.progress2);

	}

	public void onclick(View v) {
		cattask = new CatTask();
		cattask.execute("cat1.jpg", "cat2.jgp", "cat3.jpg", "cat4.jpg");
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		getMenuInflater().inflate(R.menu.activity_main, menu);
		return true;
	}

	class CatTask extends AsyncTask&lt;String, Integer, Void&gt; {

		@Override
		protected void onPreExecute() {
			super.onPreExecute();
			tvInfo.setText("Полез на крышу");
			buttonStart.setVisibility(View.INVISIBLE);
		}

		@Override
		protected Void doInBackground(String... urls) {
			try {
				int counter = 0;
				for (String url : urls) {
					// загружаем файл или лезем на другой этаж
					getFloor(counter);
					// выводим промежуточные результаты
					publishProgress(++counter);
				}

				// разъединяемся
				TimeUnit.SECONDS.sleep(1);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			return null;
		}

		@Override
		protected void onProgressUpdate(Integer... values) {
			super.onProgressUpdate(values);
			tvInfo.setText("Этаж: " + values[0]);
			horizontalprogress.setProgress(values[0]);
		}

		@Override
		protected void onPostExecute(Void result) {
			super.onPostExecute(result);
			tvInfo.setText("Залез");
			buttonStart.setVisibility(View.VISIBLE);
			horizontalprogress.setProgress(0);
		}

		private void getFloor(int floor) throws InterruptedException {
			TimeUnit.SECONDS.sleep(1);
		}
	}
}
</code></pre>	
</details>
<br>
<p>Ещё раз закрепим материал.</p>

<p>Метод <b>execute()</b> вызывается в основном потоке, чтобы начать выполнение задачи. В него можно передать набор данных определенного типа. Если что-то передаём, то этот тип будет указан первым в угловых скобках при создании наследника AsyncTask.</p>

<p>Методы <b>onPreExecute()</b> и <b>onPostExecute()</b> вызываются системой в начале и конце выполнения задачи.</p>

<p>Основной метод для тяжёлой работы - <b>doInBackground()</b>. Можно передать методу какие-то данные. В этом случае смотрим на <b>execute()</b>.</p>

<p>Метод <b>publishProgress()</b> нужен в том случае, когда требуется обрабатывать промежуточные данные. Его нужно явно вызвать в методах doInBackground(), onPreExecute() или onPostExecute(). На вход передаем промежуточные данные определенного типа. Этот тип указан вторым в угловых скобках при описании AsyncTask.</p>

<p>Метод <b>onProgressUpdate()</b> получает на вход промежуточные результаты от метода <b>publishProgress()</b>. Так как метод <b>onProgressUpdate()</b> принимает на вход набор параметров, то при передаче одного значения от <b>publishProgress</b> нужно взять первый элемент массива.</p>

<h3 class="text-warning" id="third">Используем третий параметр - возвращаемые данные</h3>

<p>Осталось рассмотреть вариант использования третьего параметра.</p>

<p>В третьем параметре указывается тип объекта, который должен вернуться из AsyncTask. Получить его можно двумя способами:</p>

<ul>
<li>Он передаётся методу <b>onPostExecute()</b>, который вызывается по окончании задачи</li>
<li>Существует метод <b>get()</b>, способный возвращать нужный объект</li>
</ul>

<p>Если мы собираемся что-то возвращать, то это надо указать в возвращаемом значении у метода <b>doInBackground()</b> и в входящем параметре для метода <b>onPostExecute()</b>.</p>

<p>Начнём с метода <b>doInBackground()</b> и изменим его описание следующим образом:</p>

<pre><code class="java">
@Override
protected Integer doInBackground(String... urls) {
    // здесь без изменений
	return 2012;
}
</code></pre>

<p>Как видите, наш метод теперь возвращает тип Integer. Пусть это будет число 2012 - напоминание про обман племени майя, которые обещали в этом году конец света. Даже коты ждали его.</p>

<p><img src="asynctask2.jpg" alt="Кот и конец света" width="500" height="381"></p>

<p>Eclipse подчеркнёт исправленный вариант, указывая не соответствие в параметрах у класса AsyncTask. Исправим:</p>

<pre><code class="java">
class CatTask extends AsyncTask&lt;String, Integer, <b>Integer</b>&gt;
</code></pre>

<p>Теперь обратимся к методу <b>onPostExecute()</b>. Тип Integer должен стать входящим параметром. Поменяем объявление метода:</p>

<pre><code class="java">
protected void onPostExecute(<b>Integer</b> result)
</code></pre>

<p>В нашем случае входящий параметр не несёт смысловой нагрузки, просто выведем значение в текстовом поле.</p>

<p>Полный код для самопроверки:</p>

<details>
    <summary>Показать код (щелкните мышкой)</summary>
	
<pre><code class="java">
// Если этот код работает, его написал Александр Климов,
// а если нет, то не знаю, кто его писал.
package ru.alexanderklimov.asynctaskdemo;

import ...

public class MainActivity extends Activity {

	CatTask cattask;
	TextView tvInfo;
	ProgressBar progress;
	Button buttonStart;
	ProgressBar horizontalprogress;

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);

		progress = (ProgressBar) findViewById(R.id.progress);
		tvInfo = (TextView) findViewById(R.id.tvInfo);
		buttonStart = (Button) findViewById(R.id.buttonStart);
		horizontalprogress = (ProgressBar) findViewById(R.id.progress2);

	}

	public void onclick(View v) {
		cattask = new CatTask();
		cattask.execute("cat1.jpg", "cat2.jgp", "cat3.jpg", "cat4.jpg");
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		getMenuInflater().inflate(R.menu.activity_main, menu);
		return true;
	}

	class CatTask extends AsyncTask&lt;String, Integer, Integer&gt; {

		@Override
		protected void onPreExecute() {
			super.onPreExecute();
			tvInfo.setText("Полез на крышу");
			buttonStart.setVisibility(View.INVISIBLE);
		}

		@Override
		protected Integer doInBackground(String... urls) {
			try {
				int counter = 0;
				for (String url : urls) {
					// загружаем файл или лезем на другой этаж
					getFloor(counter);
					// выводим промежуточные результаты
					publishProgress(++counter);
				}

				// разъединяемся
				TimeUnit.SECONDS.sleep(1);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			return 2012;
		}

		@Override
		protected void onProgressUpdate(Integer... values) {
			super.onProgressUpdate(values);
			tvInfo.setText("Этаж: " + values[0]);
			horizontalprogress.setProgress(values[0]);
		}

		@Override
		protected void onPostExecute(Integer result) {
			super.onPostExecute(result);
			tvInfo.setText("Залез" + " Возвращаем результат: " + result);
			buttonStart.setVisibility(View.VISIBLE);
			horizontalprogress.setProgress(0);
		}

		private void getFloor(int floor) throws InterruptedException {
			TimeUnit.SECONDS.sleep(1);
		}
	}
}
</code></pre>	
	
</details>

<br>
<h2 class="text-warning" id="getmethod">Метод get()</h2>

<p>Выше уже упоминалось, что метод <b>get()</b> возвращает значение задачи. Тут следует рассмотреть два момента. Первый момент - вызовем метод после выполнения задачи. Второй момент - попробуем получить значение во время выполения задачи.</p>

<p>Начнём с первого варианта. Добавим на экран активности ещё одну кнопку <b>buttonResult</b> с надписью "Получить результат":</p>

<pre><code class="xml">
&lt;Button
    android:id=&quot;@+id/buttonResult&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:onClick=&quot;onResultClick&quot;
    android:text=&quot;Получить результат&quot; /&gt;
</code></pre>

<p>Добавим код для обработчика кнопки:</p>

<pre><code class="java">
public void onResultClick(View v) {
	if (cattask == null)
		return;
	int result = -1;
	try {
		result = cattask.get();
		Toast.makeText(this, "Полученный результат: " + result, Toast.LENGTH_LONG)
				.show();
	} catch (InterruptedException e) {
		e.printStackTrace();
	} catch (ExecutionException e) {
		e.printStackTrace();
	}
}
</code></pre>

<p>Запустите приложение, далее запустите задачу нажатием первой кнопки, дождитесь окончания задачи и нажмите вторую кнопку. Во всплывающем сообщение вы увидите то же число "2012", который возвращает метод <b>onPostExecute()</b>.</p>

<p>А что случится, если задача находится в стадии выполнения, а мы вызовем метод <b>get()</b>? Давайте проверим.</p>

<p>Запустим снова приложение, нажмём на первую кнопку для запуска задачи и, не дожидаясь окончания задачи, нажмите на вторую кнопку.</p>

<p>Создатся ощущение, что программа остановилась. ProgressBar перестанет обновляться, текстовые сообщения также не выводятся в TextView. Но после окончания задачи появится текст и вернётся результат. Что же произошло?. Метод <b>get()</b> блокирует основной UI-поток и ждёт завершения AsyncTask. Это продолжается до тех пор, пока не выполнится код в методе <b>doInBackground()</b>. После этого метод <b>get()</b> возвращает результат и освобождает поток.</p>

<p>Таким образом метод блокирует поток, в котором он выполняется, и не отпустит, пока не получит какой-то результат или не выскочит исключение.</p>

<h3 class="text-warning">Тайм-аут</h3>

<p>Есть ещё реализация метода с тайм-аутом. В этом случае метод <b>get()</b> будет ждать указанное время, а потом сгенерирует Exception. Если же задача уже была завершена, то метод выполнится сразу и ждать ничего не будет.</p>

<p>Перепишем код для второй кнопки:</p>

<pre><code class="java">
public void onResultClick(View v) {
	if (cattask == null)
		return;
	int result = -1;
	try {
		result = cattask.get(1, TimeUnit.SECONDS);
		Toast.makeText(this, "Полученный результат: " + result,
				Toast.LENGTH_LONG).show();
	} catch (InterruptedException e) {
		e.printStackTrace();
	} catch (ExecutionException e) {
		e.printStackTrace();
	} catch (TimeoutException e) {
		Log.e("AsyncTaskDemo", "get timeout, result = " + result);
		e.printStackTrace();
	}
}
</code></pre>

<p>Смотрим, что получилось. Приложение снова подвисает, но через секунду оживает и продолжает работу. Метод <b>get()</b> ждёт одну секунду, и если не получает результат, то генерирует исключение <b>TimeoutException</b>. Мы обрабатываем исключение и выводим в лог соответствующее сообщение. А приложение продолжат выполнять задачу и после успешной обработки метода <b>onPostExecute()</b> выводит результат.</p>

<h2 class="text-warning" id="cancelmethod">Метод cancel() - отменяем задачу</h2>

<p>Метод <b>cancel()</b> позволяет указать на отмену уже выполняющейся задачи. У метода один boolean-параметр, который указывает, может ли система прервать выполнение потока.</p>

<p>Кроме того, в методе <b>doInBackground()</b> можно проверять метод <b>isCancelled()</b>. Как только мы выполним метод <b>cancel()</b>, метод <b>isCancelled()</b> будет возвращать <i>true</i> и мы должны завершить метод <b>doInBackground()</b>. Таким образом, метод <b>cancel()</b>  служит своеобразной меткой, что задачу нужно отменить. А метод <b>isCancelled()</b> будет считывать результат предыдущего метода и позволет выполнит код для завершения задачи.</p>

<p>Вернёмя к нашей истории с упрямым котом, который лезет на крышу. Оставим на экране две кнопки для запуска и отмены задачи. Саму задачу немного упростим, убрав отвлекающий код (используем один из первых вариантов примера в начале статьи).</p>

<pre><code class="java">
// Если этот код работает, его написал Александр Климов,
// а если нет, то не знаю, кто его писал.
package ru.alexanderklimov.asynctaskdemo;

import ...

public class MainActivity extends Activity {

	CatTask cattask;
	TextView tvInfo;
	Button buttonStart;
	ProgressBar horizontalprogress;

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);

		tvInfo = (TextView) findViewById(R.id.tvInfo);
		buttonStart = (Button) findViewById(R.id.buttonStart);
		horizontalprogress = (ProgressBar) findViewById(R.id.progress2);
	}

	public void onclick(View v) {
		cattask = new CatTask();
		cattask.execute();
	}

	public void onCancelClick(View v) {
		cattask.cancel(true);
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		getMenuInflater().inflate(R.menu.activity_main, menu);
		return true;
	}

	class CatTask extends AsyncTask&lt;Void, Integer, Void&gt; {

		@Override
		protected void onPreExecute() {
			super.onPreExecute();
			tvInfo.setText("Полез на крышу");
			buttonStart.setVisibility(View.INVISIBLE);
		}

		@Override
		protected Void doInBackground(Void... params) {
			try {
				int counter = 0;

				for (int i = 0; i &lt; 14; i++) {
					getFloor(counter);
					publishProgress(++counter);
					if (isCancelled())
						return null;
				}
				// разъединяемся
				TimeUnit.SECONDS.sleep(1);

			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			return null;
		}

		@Override
		protected void onProgressUpdate(Integer... values) {
			super.onProgressUpdate(values);
			tvInfo.setText("Этаж: " + values[0]);
			horizontalprogress.setProgress(values[0]);
		}

		@Override
		protected void onPostExecute(Void result) {
			super.onPostExecute(result);
			tvInfo.setText("Залез");
			buttonStart.setVisibility(View.VISIBLE);
			horizontalprogress.setProgress(0);
		}

		@Override
		protected void onCancelled() {
			super.onCancelled();
			tvInfo.setText("Передумал лезть на крышу");
			buttonStart.setVisibility(View.VISIBLE);
			horizontalprogress.setProgress(0);
		}

		private void getFloor(int floor) throws InterruptedException {
			TimeUnit.SECONDS.sleep(1);
		}
	}
}
</code></pre>

<p>Когда мы нажимаем на кнопку "Отменить операцию", то в методе <b>cancel()</b> используем параметр, равный <i>true</i>. В методе <b>doInBackground()</b> при работе цикла идёт проверка отмены (метод isCancelled()). Если приложение видит, что пользователь выбрал отмену задачи, то вместо метода <b>onPostExecute()</b> вызывается метод <b>onCancelled()</b>, в котором и прописываем свою логику кода.</p>

<p>В Android 4.0 появился ещё один метод <b>onCancelled(Void result)</b>, способный принимать результат от метода <b>doInBackground()</b>.</p>

<pre><code class="java">
@Override
protected void onCancelled(Void result) {
	Log.d("AsyncTask", "onCancelled(Void) start");
	super.onCancelled(result);
	Log.d("AsyncTask", "onCancelled(Void) finish");
}
</code></pre>

<h2 class="text-warning" id="asyncstatus">Текущее состояние задачи</h2>

<p>Мы можем определить, в каком состоянии сейчас находится задача. Существует три состояния:</p>

<ul>
<li><b>PENDING</b> – задача не запущена</li>
<li><b>RUNNING</b> – задача выполняется</li>
<li><b>FINISHED</b> – задача успешно завершена. Метод onPostExecute() отработал</li>
</ul>

<p>Вы можете самостоятельно проверить, в каком состоянии находится ваша задача, добавив код в нужном месте:</p>

<pre><code class="java">
Toast.makeText(this, cattask.getStatus().toString(), Toast.LENGTH_SHORT).show();
</code></pre>

<p>Вкратце, когда вы создаёте задачу (new CatTask()), то состояние <b>PENDING</b>. Когда вы запускаете задачу (execute()) и задача работает, то состояние <b>RUNNING</b>. Когда задача завершится, то состояние <b>FINISHED</b>. Если вы отменили задачу, то состояние по-прежнему будет <b>RUNNING</b>, поэтому используйте проверку через метод <b>isCancelled()</b> для более точного определения состояния:</p>

<pre><code class="java">
if (cattask.isCancelled())
    Toast.makeText(this, "Отмена задачи", Toast.LENGTH_SHORT).show();
else
    Toast.makeText(this, cattask.getStatus().toString(), Toast.LENGTH_SHORT).show();
</code></pre>

<p>В моих опытах после отмены сначала показывало состояние <b>RUNNING</b>, а после повторной проверки уже показывало <b>FINISHED</b>, возможно состояние не сразу устанавливается.</p>

<h2 class="text-warning" id="rotatescreen">Поворот экрана</h2>

<p>Как вы знаете, при повороте экрана активность пересоздаётся. А что происходит с задачей? При повороте старые объекты будут потеряны, в том числе и ссылка на нашу задачу. Фактически получается, что при повороте создаётся ещё одна задача, которая начинает выполняться с самого начала, при этом где-то выполняется и старая задача.</p>

<p>Ситуация не совсем приятная. Для ознакомления с решениями этой задачи рекомендую почитать статью <a href="http://startandroid.ru/uroki/vse-uroki-spiskom/154-urok-91-asynctask-povorot-ekrana.html" >Урок 91. AsyncTask. Поворот экрана</a>, а заодно и другие материалы с сайта, связанные с AsyncTask.</p>

<h2 class="text-warning" id="samples">Примеры</h2>

<p><a href="../asynctask-imageinet.html" >Используем AsyncTask для загрузки изображений из сети</a></p>
<p><a href="../asynctask-readfile.html" >Используем AsyncTask для загрузки текстового файла из сети</a></p>


</div><!--/span-->
        </div><!--/row-->	
		  
        </div><!--/span-->
		
		<div class="span2">
            <div class="well sidebar-nav">
    <h4><span class="label label-info">Реклама</span></h4>
    <script type="text/javascript"><!--
    google_ad_client = "pub-4224968932772057";
    /* 120x600AlexKlimov */
    google_ad_slot = "0305552138";
    google_ad_width = 120;
    google_ad_height = 600;
    //-->
    </script>
    <script type="text/javascript"
    src="../../../pagead2.googlesyndication.com/pagead/f.txt">
    </script>
</div><!--/.well -->        </div><!--/span-->
		
      </div><!--/row-->
	  
	
      <hr>
	  
	  	  <div class="row-fluid">
	  <div class="span12">
	  <img src="../../images/cat_bottom.png" align="right" />
</div><!--/span-->
        </div><!--/row-->

<footer>
    <noindex>
    <span style="float:left; margin:3px 1px 1px 2px;">
	    © 2014 <a href="mailto:rusproject@mail.ru">А.Климов</a>
		
		<!-- Place this code where you want the badge to render. -->
<a href="http://plus.google.com/109061106977829925124?prsrc=3" rel="publisher" style="text-decoration:none;">
<img src="../../../ssl.gstatic.com/images/icons/gplus-16.png" alt="Google+" style="border:0;width:16px;height:16px;"/></a>

    </span>
	
		<span style="float: right; margin:3px 5px 1px 1px; font-size:22px;">
        <!--Rating@Mail.ru LOGO--><a target=_top
        href="http://top.mail.ru/jump?from=228158"><img
        SRC="http://top-fwz1.mail.ru/counter?id=228158;t=223;l=1"
        border=0 height=31 width=88
        alt="Рейтинг@Mail.ru"/></a><!--/LOGO-->
	</span>
    
    <span style="float: right; margin:2px 70px 1px 1px; font-size:22px;">
        <a href="http://feeds.feedburner.com/alexanderklimov/VJcl"><img src="../../../feeds.feedburner.com/_fc/alexanderklimov/VJcle080.gif?bg=0099CC&amp;fg=444444&amp;anim=0" height="26" width="88" style="border:0" alt="" /></a>
	</span>
	
<div style="float: right; margin:2px 70px 1px 1px;">
<!-- Place this tag where you want the +1 button to render. -->
<div class="g-plusone" data-size="small" data-annotation="inline" data-width="300" data-align="right" ></div>

</div>

<!-- Place this tag after the last +1 button tag. -->
<script type="text/javascript">
  window.___gcfg = {lang: 'ru'};

  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '../../../apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
	

    </noindex>
</footer>

</div><!--/.fluid-container-->    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../../assets/js/jquery.js"></script>
    <script src="../../assets/js/bootstrap-transition.js"></script>
    <script src="../../assets/js/bootstrap-alert.js"></script>
    <script src="../../assets/js/bootstrap-modal.js"></script>
    <script src="../../assets/js/bootstrap-dropdown.js"></script>
    <script src="../../assets/js/bootstrap-scrollspy.js"></script>
    <script src="../../assets/js/bootstrap-tab.js"></script>
    <script src="../../assets/js/bootstrap-tooltip.js"></script>
    <script src="../../assets/js/bootstrap-popover.js"></script>
    <script src="../../assets/js/bootstrap-button.js"></script>
    <script src="../../assets/js/bootstrap-collapse.js"></script>
    <script src="../../assets/js/bootstrap-carousel.js"></script>
    <script src="../../assets/js/bootstrap-typeahead.js"></script>
    <script src="../../../code.jquery.com/jquery-1.7.min.js"></script>
</body>

<!-- Mirrored from developer.alexanderklimov.ru/android/theory/asynctask.php by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Jul 2014 14:51:53 GMT -->
</html>